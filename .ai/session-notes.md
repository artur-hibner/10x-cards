<conversation_summary><decisions> 1. Użytkownicy będą zarządzani przez Supabase z polami: id, email, created_at, confirmed_at. 2. Wszystkie fiszki (flashcards) będą przechowywane w jednej tabeli, gdzie atrybut "source" rozróżnia ich pochodzenie: "ai-full" (wygenerowane przez AI bez edycji), "ai-edited" (wygenerowane przez AI, ale edytowane przez użytkownika) oraz "manual" (tworzone ręcznie). 3. Tabela flashcards będzie zawierać pola: id (bigserial), front (do 200 znaków), back (do 500 znaków), source, created_at, updated_at, generation_id (klucz obcy) oraz user_id (klucz obcy). 4. Tabela generations zostanie zaprojektowana z polami: id (bigserial), user_id (klucz obcy), model, generated_count, accepted_unedited_count, accepted_edited_count, source_text_hash (stosowany standardowy algorytm SHA-256), source_text_length (sprawdzany CHECK constraint dla zakresu 1000–10000 znaków), generation_time oraz odpowiednie timestampy. 5. Tabela generation_error_logs będzie zawierać: id (bigserial), user_id (klucz obcy), model, source_text_hash, source_text_length (z CHECK constraint), error_code oraz error_message. 6. Zastosowano podstawowe ograniczenia danych (CHECK constraints, NOT NULL) oraz minimalne indeksowanie na kluczowych kolumnach (user_id, generation_id) odpowiednie na etapie MVP. 7. Mechanizm autoryzacji (RLS) oparty na user_id zapewni, że użytkownicy mają dostęp tylko do swoich danych, zgodnie z autoryzacją Supabase. 8. Wprowadzony zostanie automatyczny trigger aktualizujący pole updated_at w tabeli flashcards.
</decisions><matched_recommendations> 1. Zdefiniowanie kluczowych tabel (flashcards, generations, generation_error_logs) oraz ich atrybutów i ograniczeń zgodnie z wymaganiami MVP. 2. Implementacja relacji jeden-do-wielu między użytkownikami a fiszkami, generacjami i logami błędów. 3. Użycie CHECK constraints dla weryfikacji długości tekstu (source_text_length) i wartości atrybutu source z zachowaniem case sensitivity. 4. Wdrożenie mechanizmu RLS zaprojektowanego na bazie user_id, aby zabezpieczyć dane użytkowników. 5. Zastosowanie automatycznych triggerów do aktualizacji timestampów (updated_at) przy modyfikacjach rekordów.
</matched_recommendations><database_planning_summary>Projekt bazy danych dla MVP obejmuje następujące kluczowe elementy:
• Tabela users jest zarządzana przez Supabase i zawiera podstawowe dane uwierzytelniające.
• Tabela flashcards przechowuje zarówno fiszki generowane przez AI, jak i tworzone ręcznie, przy czym różnicowanie odbywa się za pomocą pola "source". Ograniczenia długości: front do 200 znaków, back do 500 znaków.
• Tabela generations zawiera dane dotyczące sesji generowania fiszek, w tym liczniki, atrybuty tekstowe związane z materiałem wejściowym (source_text_hash, source_text_length) oraz czas trwania generacji (generation_time).
• Tabela generation_error_logs rejestruje błędy występujące podczas generacji z odpowiednimi ograniczeniami.
• Wszystkie tabele poza usersem posiadają CHECK constraints, zapewniające integralność danych (np. sprawdzają zakres source_text_length oraz poprawność wartości source z zachowaniem case sensitivity).
• Mechanizm RLS oparty na user_id zapewni, że każdy użytkownik ma dostęp tylko do swoich danych, a automatyczne triggery dbają o aktualizację pól timestamp (takich jak updated_at).
• Na etapie MVP wybrano prostą strategię indeksowania (na kluczach głównych i obcych), co jest wystarczające przy niewielkiej liczbie rekordów, z możliwością rozbudowy w kolejnych wersjach.
</database_planning_summary><unresolved_issues> 1. Potencjalne rozszerzenie mechanizmów bezpieczeństwa przy wdrożeniu bardziej zaawansowanych triggerów w przyszłości. 2. Możliwość rozbudowy strategii indeksowania i partycjonowania wraz ze wzrostem liczby rekordów w późniejszych etapach projektu.
</unresolved_issues></conversation_summary>
